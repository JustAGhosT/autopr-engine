name: "Phase 1: Complete PR Review and Issue Management"
description: "Comprehensive PR review analysis with automatic issue creation and AI assignment"

triggers:
  - on: pull_request
    events: [opened, synchronize]
  - on: pull_request_review
    events: [submitted]

inputs:
  severity_threshold:
    type: string
    default: "medium"
    description: "Minimum severity level for processing issues"
  auto_assign:
    type: boolean
    default: true
    description: "Automatically assign issues to AI tools"
  create_linear_tickets:
    type: boolean
    default: true
    description: "Create Linear tickets for feature development"
  notify_team:
    type: boolean
    default: true
    description: "Send team notifications for created issues"

steps:
  - name: "Collect PR Review Data"
    id: collect_reviews
    description: "Gather all AI review data from CodeRabbit, Copilot, and TypeScript Check"
    uses: script
    with:
      script: |
        import json
        import os
        import requests
        
        # Initialize review data structure
        review_data = {
            'coderabbit': {'findings': []},
            'copilot': {'suggestions': []},
            'typescript_check': {'errors': []}
        }
        
        # Get CodeRabbit review data
        try:
            # CodeRabbit stores review data in PR comments/reviews
            coderabbit_data = get_coderabbit_review_data(pr_number)
            review_data['coderabbit'] = coderabbit_data
        except Exception as e:
            print(f"Error collecting CodeRabbit data: {e}")
        
        # Get GitHub Copilot suggestions
        try:
            copilot_data = get_copilot_suggestions(pr_number)
            review_data['copilot'] = copilot_data
        except Exception as e:
            print(f"Error collecting Copilot data: {e}")
        
        # Get AI TypeScript Check results
        try:
            ts_data = get_typescript_check_results(pr_number)
            review_data['typescript_check'] = ts_data
        except Exception as e:
            print(f"Error collecting TypeScript data: {e}")
        
        # Output the collected data
        return {
            'review_data': review_data,
            'pr_number': pr_number,
            'repository': repository
        }
        
        def get_coderabbit_review_data(pr_number):
            """Extract CodeRabbit findings from PR reviews"""
            # This would integrate with CodeRabbit's API or parse review comments
            # For now, return sample data structure
            return {
                'findings': [
                    {
                        'category': 'typescript',
                        'severity': 'high',
                        'title': 'Missing type annotation',
                        'description': 'Function parameter lacks proper TypeScript type',
                        'file': 'src/components/Dashboard.tsx',
                        'line': 25,
                        'suggestion': 'Add interface for props parameter',
                        'confidence': 0.9,
                        'tags': ['typescript', 'type-safety']
                    }
                ]
            }
        
        def get_copilot_suggestions(pr_number):
            """Get GitHub Copilot Chat suggestions"""
            return {
                'suggestions': [
                    {
                        'type': 'improvement',
                        'priority': 'medium',
                        'title': 'Performance optimization opportunity',
                        'explanation': 'Consider memoizing this component',
                        'file': 'src/components/Dashboard.tsx',
                        'code': 'const MemoizedDashboard = React.memo(Dashboard);'
                    }
                ]
            }
        
        def get_typescript_check_results(pr_number):
            """Get AI TypeScript Check results"""
            return {
                'errors': [
                    {
                        'category': 'error',
                        'messageText': 'Property "user" does not exist on type "Props"',
                        'file': 'src/components/Dashboard.tsx',
                        'line': 15,
                        'suggestion': 'Add user property to Props interface'
                    }
                ]
            }

  - name: "Analyze PR Reviews"
    id: analyze_reviews
    description: "Use PR Review Analyzer to process all review data"
    uses: ./actions/pr_review_analyzer.py
    with:
      pr_number: "${{ steps.collect_reviews.outputs.pr_number }}"
      repository: "${{ steps.collect_reviews.outputs.repository }}"
      review_data: "${{ steps.collect_reviews.outputs.review_data }}"
      severity_threshold: "${{ inputs.severity_threshold }}"
      auto_assign: "${{ inputs.auto_assign }}"

  - name: "Create Issues and Tickets"
    id: create_issues
    description: "Create GitHub issues and Linear tickets based on analysis"
    uses: ./actions/issue_creator.py
    with:
      github_issues: "${{ steps.analyze_reviews.outputs.github_issues_created }}"
      linear_tickets: "${{ steps.analyze_reviews.outputs.linear_tickets_created }}"
      ai_assignments: "${{ steps.analyze_reviews.outputs.ai_assignments }}"
      repository: "${{ steps.collect_reviews.outputs.repository }}"
      create_github: true
      create_linear: "${{ inputs.create_linear_tickets }}"
      notify_ai_tools: true

  - name: "Complex Task AutoGen Processing"
    id: autogen_processing
    description: "Use AutoGen for complex multi-agent tasks if needed"
    condition: "${{ steps.analyze_reviews.outputs.should_use_autogen }}"
    uses: ./actions/autogen_implementation.py
    with:
      task_description: "Resolve complex issues found in PR review"
      task_type: "bug_fix"
      repository: "${{ steps.collect_reviews.outputs.repository }}"
      file_paths: "${{ steps.analyze_reviews.outputs.affected_files }}"
      requirements: "${{ steps.analyze_reviews.outputs.complex_requirements }}"
      complexity_level: "complex"
      max_agents: 4

  - name: "Update PR Status"
    id: update_pr
    description: "Update PR with review results and next steps"
    uses: script
    with:
      script: |
        import json
        
        # Get results from previous steps
        analysis_results = ${{ steps.analyze_reviews.outputs }}
        issue_results = ${{ steps.create_issues.outputs }}
        autogen_results = ${{ steps.autogen_processing.outputs if steps.autogen_processing.outputs else {} }}
        
        # Create comprehensive PR comment
        comment_body = create_pr_summary_comment(
            analysis_results,
            issue_results,
            autogen_results
        )
        
        # Post comment to PR
        post_pr_comment(pr_number, comment_body)
        
        # Set PR status based on findings
        if analysis_results.get('should_block_merge', False):
            set_pr_status('failure', 'Critical issues found - merge blocked')
        else:
            set_pr_status('success', 'Review completed - ready for human review')
        
        return {
            'comment_posted': True,
            'status_updated': True,
            'merge_blocked': analysis_results.get('should_block_merge', False)
        }
        
        def create_pr_summary_comment(analysis, issues, autogen):
            """Create comprehensive PR summary comment"""
            
            comment = f"""
## 🤖 AI Review Summary

{analysis.get('analysis_summary', 'No analysis summary available')}

### 📊 Issues Found
- **Total Issues**: {len(analysis.get('issues_found', []))}
- **Severity Breakdown**: {format_severity_breakdown(analysis.get('issues_found', []))}

### 🎯 Actions Taken

#### GitHub Issues Created
{format_github_issues(issues.get('github_issues_created', []))}

#### Linear Tickets Created  
{format_linear_tickets(issues.get('linear_tickets_created', []))}

#### AI Assignments
{format_ai_assignments(issues.get('ai_notifications_sent', []))}

### 🚦 Next Steps

#### Immediate Actions Required
{format_immediate_actions(analysis.get('issues_found', []))}

#### Automated Processing
{format_automated_processing(issues.get('ai_notifications_sent', []))}

### 🔄 AutoGen Multi-Agent Processing
{format_autogen_results(autogen) if autogen else 'No complex multi-agent tasks required'}

---
*This review was automatically generated by AutoPR Phase 1 workflow*
            """
            
            return comment.strip()
        
        def format_severity_breakdown(issues):
            severity_counts = {}
            for issue in issues:
                severity = issue.get('severity', 'unknown')
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            return ' | '.join([f"{severity.title()}: {count}" for severity, count in severity_counts.items()])
        
        def format_github_issues(issues):
            if not issues:
                return "None created"
            
            formatted = []
            for issue in issues:
                formatted.append(f"- [#{issue['number']}]({issue['url']}) - {issue['title']}")
            
            return '\n'.join(formatted)
        
        def format_linear_tickets(tickets):
            if not tickets:
                return "None created"
            
            formatted = []
            for ticket in tickets:
                formatted.append(f"- [{ticket['number']}]({ticket['url']}) - {ticket['title']}")
            
            return '\n'.join(formatted)
        
        def format_ai_assignments(notifications):
            if not notifications:
                return "No AI assignments made"
            
            formatted = []
            for notification in notifications:
                ai_tool = notification.get('ai_tool', 'Unknown')
                status = notification.get('status', 'unknown')
                message = notification.get('message', 'No details')
                
                formatted.append(f"- **{ai_tool.title()}**: {status} - {message}")
            
            return '\n'.join(formatted)
        
        def format_immediate_actions(issues):
            critical_issues = [issue for issue in issues if issue.get('severity') in ['critical', 'high']]
            
            if not critical_issues:
                return "✅ No immediate actions required"
            
            actions = []
            for issue in critical_issues:
                actions.append(f"- **{issue.get('title', 'Unknown')}**: {issue.get('description', 'No description')}")
            
            return '\n'.join(actions)
        
        def format_automated_processing(notifications):
            if not notifications:
                return "No automated processing scheduled"
            
            processing = []
            for notification in notifications:
                if notification.get('status') == 'notified':
                    ai_tool = notification.get('ai_tool', 'Unknown')
                    processing.append(f"- {ai_tool.title()} is processing assigned tasks")
            
            return '\n'.join(processing) if processing else "All AI tools notified, processing in progress"
        
        def format_autogen_results(autogen_results):
            if not autogen_results.get('success', False):
                return "AutoGen processing not required or failed"
            
            return f"""
**Implementation Plan**: {autogen_results.get('implementation_plan', 'Not available')[:200]}...

**Code Changes**: {len(autogen_results.get('code_changes', {}))} files modified
**Test Files**: {len(autogen_results.get('test_files', {}))} test files created
**Quality Score**: {autogen_results.get('quality_score', 0)}/100
            """
        
        def post_pr_comment(pr_number, body):
            """Post comment to PR"""
            # This would use GitHub API to post comment
            print(f"Posting comment to PR #{pr_number}")
            print(body)
        
        def set_pr_status(state, description):
            """Set PR status check"""
            # This would use GitHub API to set status
            print(f"Setting PR status: {state} - {description}")

  - name: "Send Team Notifications"
    id: notify_team
    description: "Send notifications to relevant team channels"
    condition: ${{ inputs.notify_team }}
    uses: script
    with:
      script: |
        import json
        
        # Prepare notification data
        analysis_results = ${{ steps.analyze_reviews.outputs }}
        issue_results = ${{ steps.create_issues.outputs }}
        
        # Send Slack notifications
        send_slack_notifications(analysis_results, issue_results)
        
        # Send email notifications for critical issues
        critical_issues = [
            issue for issue in analysis_results.get('issues_found', [])
            if issue.get('severity') == 'critical'
        ]
        
        if critical_issues:
            send_email_notifications(critical_issues)
        
        return {
            'slack_sent': True,
            'email_sent': len(critical_issues) > 0,
            'critical_issues_count': len(critical_issues)
        }
        
        def send_slack_notifications(analysis, issues):
            """Send Slack notifications to relevant channels"""
            
            # Main development channel notification
            dev_channel_message = {
                "text": f"🔍 PR Review Completed - {analysis.get('analysis_summary', 'Analysis complete')}",
                "attachments": [
                    {
                        "color": "good" if not analysis.get('should_block_merge') else "danger",
                        "fields": [
                            {
                                "title": "Issues Found",
                                "value": str(len(analysis.get('issues_found', []))),
                                "short": True
                            },
                            {
                                "title": "Actions Created",
                                "value": f"GitHub: {len(issues.get('github_issues_created', []))}, Linear: {len(issues.get('linear_tickets_created', []))}",
                                "short": True
                            }
                        ]
                    }
                ]
            }
            
            # Send to #development channel
            send_slack_message("#development", dev_channel_message)
            
            # Send specific notifications to AI tool channels
            for notification in issues.get('ai_notifications_sent', []):
                ai_tool = notification.get('ai_tool')
                if ai_tool == 'charlie':
                    send_slack_message("#charlie-ai", {
                        "text": f"🤖 New TypeScript tasks assigned to Charlie",
                        "attachments": [notification]
                    })
                elif ai_tool == 'snyk':
                    send_slack_message("#security", {
                        "text": f"🔒 Security issues detected and assigned to Snyk",
                        "attachments": [notification]
                    })
        
        def send_email_notifications(critical_issues):
            """Send email notifications for critical issues"""
            
            email_body = f"""
Critical Issues Detected in PR Review

{len(critical_issues)} critical issues require immediate attention:

{format_critical_issues_for_email(critical_issues)}

Please review and take immediate action.
            """
            
            # Send to team leads
            send_email(["tech-lead@company.com", "security@company.com"], 
                      "Critical Issues in PR Review", email_body)
        
        def format_critical_issues_for_email(issues):
            formatted = []
            for issue in issues:
                formatted.append(f"""
- {issue.get('title', 'Unknown Issue')}
  File: {issue.get('file_path', 'Unknown')}
  Description: {issue.get('description', 'No description')}
  Severity: {issue.get('severity', 'Unknown')}
                """)
            return '\n'.join(formatted)
        
        def send_slack_message(channel, message):
            """Send message to Slack channel"""
            print(f"Sending Slack message to {channel}: {json.dumps(message, indent=2)}")
        
        def send_email(recipients, subject, body):
            """Send email notification"""
            print(f"Sending email to {recipients}: {subject}")
            print(body)

outputs:
  analysis_complete:
    description: "Whether the analysis completed successfully"
    value: ${{ steps.analyze_reviews.outputs.success }}
  
  issues_created:
    description: "Total number of issues and tickets created"
    value: ${{ steps.create_issues.outputs.success_count }}
  
  merge_blocked:
    description: "Whether the merge should be blocked due to critical issues"
    value: ${{ steps.analyze_reviews.outputs.should_block_merge }}
  
  ai_assignments:
    description: "AI tools that were assigned tasks"
    value: ${{ steps.create_issues.outputs.ai_notifications_sent }}
  
  autogen_used:
    description: "Whether AutoGen multi-agent processing was used"
    value: ${{ steps.autogen_processing.outputs.success if steps.autogen_processing.outputs else false }}

# Workflow metadata
metadata:
  version: "1.0.0"
  phase: "1"
  complexity: "medium"
  estimated_duration: "5-15 minutes"
  dependencies:
    - "CodeRabbit AI"
    - "GitHub Copilot"
    - "AI TypeScript Check"
    - "Linear API"
    - "Slack API"
  requirements:
    - "GITHUB_TOKEN"
    - "LINEAR_API_KEY"
    - "SLACK_WEBHOOK_URL"
    - "OPENAI_API_KEY" 